
---(
    This module defines parsing of the language input
)
fmod LANG-SYNTAX is

    protecting QID-LIST .

    --- special definition for any token read by maude tokenizer
    sort Token . 
    op token : Qid -> Token 
        [special (id-hook Bubble     (1 1) --- min/max number of any token for the term (only 1 token allowed)
                op-hook qidSymbol (<Qids> : ~> Qid)
                id-hook Exclude (pass, function, `(, `), ;, =, return, :, [, ], {, }, `, , true, false, ~, [], <>, /\, \/, ->, <->, =>, <=> )) ] . --- disallow special words

    sort Expr .
    subsort Token < Expr .
    sort Stmt .
    sort Decl .
    sort TopLevel .
    subsort Stmt Decl < TopLevel .
    sorts Arg ArgList .
    subsort Expr < Arg < ArgList .
    sort TokenList .
    subsort Token < TokenList .
    subsort TokenList < ArgList .

    --- Parsing
    op _; : Expr -> Stmt [gather (&)] .
    op _+_ : Expr Expr -> Expr [gather (e E) prec 33] .
    op _-_ : Expr Expr -> Expr [gather (e E) prec 33] .
    op _*_ : Expr Expr -> Expr [gather (e E) prec 31] .
    op _/_ : Expr Expr -> Expr [gather (e E) prec 31] .
    op -_ : Expr -> Expr .

    op _==_ : Expr Expr -> Expr [gather (e e) prec 51] .
    op _!=_ : Expr Expr -> Expr [gather (e e) prec 51] .
    op _>_ : Expr Expr -> Expr [gather (e E) prec 37] .
    op _<_ : Expr Expr -> Expr [gather (e E) prec 37] .
    op _>=_ : Expr Expr -> Expr [gather (e E) prec 37] .
    op _<=_ : Expr Expr -> Expr [gather (e E) prec 37] .
    op _&&_ : Expr Expr -> Expr [gather (e E) prec 55] .
    op _||_ : Expr Expr -> Expr [gather (e E) prec 59] .
    op !_ : Expr -> Expr [prec 53] .

    op if_{_} : Expr Stmt -> Stmt .
    op if_{_} else {_} : Expr Stmt Stmt -> Stmt .
    op while_{_} : Expr Stmt -> Stmt .

    op `(_`) : Expr -> Expr .
    op _=_; : Expr Expr -> Stmt .
    op pass ; : -> Stmt .
    op __ : Stmt Stmt -> Stmt [assoc prec 50] .
    op function_`(`) {_} : Token Stmt -> Stmt .
    op function_`(_`) {_} : Token TokenList Stmt -> Stmt .

    sort Funccall .
    subsort Funccall < Expr .

    op _`(`) : Token -> Funccall .
    op _`(_`) : Token ArgList -> Funccall [prec 1 gather (e &)] .
    op _,_ : ArgList ArgList -> ArgList [assoc] .
    op return_; : Expr -> Stmt .

    sort DictEntrySynt DictEntryListSynt .
    op _:_ : Expr Expr -> DictEntrySynt .
    subsort DictEntrySynt < DictEntryListSynt .
    op _,_ : DictEntryListSynt DictEntryListSynt -> DictEntryListSynt [assoc prec 50] .
    op {_} : DictEntryListSynt -> Expr .
    op {} : -> Expr .
    op _._ : Expr Token -> Expr [prec 10 gather (E e)] .

    op _[_] : Expr Expr -> Expr [prec 10 gather (E &)] .

    op [_] : ArgList -> Expr [prec 2] .
    op [] : -> Expr [prec 2] .

    ops true false : -> Expr .
endfm


---(
    Definitions of the inner structure of language execution
)
fmod LANG-AST is

    protecting INT .
    protecting STRING .
    protecting FLOAT .

    sort AST .

    sorts ExprAST StmtAST DeclAST .
    subsort ExprAST DeclAST < StmtAST < AST .

    op pass : -> StmtAST [ctor] . --- nothing
    op _;_ : StmtAST StmtAST -> StmtAST [ctor assoc id: pass] .

    ops $add $sub $mult $div $gt $ge $lt $le $and $or $eq $ne : ExprAST ExprAST -> ExprAST [ctor] . --- binary operations
    ops $neg : ExprAST -> ExprAST [ctor] . --- unary operations
    op assign : ExprAST ExprAST -> StmtAST [ctor] . --- assignment
    op $ifelse : ExprAST StmtAST StmtAST -> StmtAST [ctor] . --- conditional branching
    op $while : ExprAST StmtAST -> StmtAST [ctor] .
    
    op str : String -> ExprAST [ctor] . --- string literal
    op int : Int -> ExprAST [ctor] . --- integer literal
    op float : Float -> ExprAST [ctor] . --- integer literal
    op bool : Bool -> ExprAST [ctor] .

    sort Ident .
    subsort Ident < ExprAST .
    op id : String -> Ident [ctor] . --- identifier
    
    sorts ArgAST ArgListAST ParamAST ParamListAST .
    subsort ExprAST < ArgAST < ArgListAST .
    subsort ParamListAST < ArgListAST .

    op empty : -> ParamListAST [ctor] . --- list of parameters in function definition
    op _,_ : ArgListAST ArgListAST -> ArgListAST [ctor assoc id: empty] . --- list of passed arguments in function call
    op _,_ : ParamListAST ParamListAST -> ParamListAST [ditto] .
    op _,_ : ArgListAST ParamListAST -> ArgListAST [ditto] .
    op _,_ : ParamListAST ArgListAST -> ArgListAST [ditto] .

    subsort Ident < ParamListAST .

    op function : String FuncParams StmtAST -> DeclAST [ctor] . --- function definition
    op function : String FuncParams -> DeclAST [ctor] .

    op return : ExprAST -> StmtAST [ctor] . --- return from function
    op call : String CallArgs -> ExprAST [ctor] . --- function call

    sort CallArgs .
    op args : ArgListAST -> CallArgs [ctor] .

    sort FuncParams .
    op params : ParamListAST -> FuncParams [ctor] .

    op list : ArgListAST -> ExprAST [ctor] .
    op dict : DictEntryListAST -> ExprAST [ctor] .

    sort DictEntryAST DictEntryListAST .
    subsort DictEntryAST < DictEntryListAST .
    op emptyDict : -> DictEntryListAST [ctor] .
    op _,_ : DictEntryListAST DictEntryListAST -> DictEntryListAST [ctor assoc id: emptyDict] .
    op dictItem : ExprAST ExprAST -> DictEntryAST [ctor] .

    op member : ExprAST String -> ExprAST [ctor] .
    op index : ExprAST ExprAST -> ExprAST [ctor] .

    op abort : -> StmtAST [ctor] . --- end execution

    sort IO .
    op $lock : ExprAST IO -> StmtAST [ctor] .
    op $dispatch : ExprAST IO -> StmtAST [ctor] .


    sort Value .
    op void : -> Value [ctor] .
    op delete : -> Value [ctor] .
    op strVal : String -> Value [ctor] .
    op intVal : Int -> Value [ctor] .
    op floatVal : Float -> Value [ctor] .
    op boolVal : Bool -> Value [ctor] .
    op refVal : Nat -> Value [ctor] .
    op listVal : RefList -> Value [ctor] . --- list contains its index on stack and length
    op dictVal : Dictionary -> Value [ctor] .

    sort RefList .
    subsort Nat < RefList .
    op emptyList : -> RefList .
    op _,_ : RefList RefList -> RefList [ctor assoc comm id: emptyList] .
    op listItem : RefList Nat -> Nat .
    op length : RefList -> Nat .

    sort Dictionary .
    sort DictValue .
    subsort DictValue < Dictionary .
    op empty : -> Dictionary [ctor] .
    op _;_ : Dictionary Dictionary -> Dictionary [ctor assoc comm id: empty] .
    op d : String Nat -> DictValue [ctor] .

    op insert : String Nat Dictionary -> Dictionary .
    op _[_] : Dictionary String -> Nat .
    op hasMapping : Dictionary String -> Bool .

    vars STR STR' : String .
    vars N N' : Nat .
    var L : RefList .
    var D : Dictionary .
    eq insert(STR, N, (d(STR, N') ; D)) = d(STR, N) ; D .
    eq insert(STR, N, D) = d(STR, N) ; D [owise] .

    eq (d(STR, N) ; D) [ STR ] = N .

    eq hasMapping(d(STR, N) ; D, STR) = true .
    eq hasMapping(D, STR) = false [owise] .
    
    eq listItem((N, L), s(N')) = listItem(L, N') .
    eq listItem((N, L), 0) = N .

    eq length(N, L) = s(length(L)) .
    eq length(emptyList) = 0 .

    sort IOValue .
    subsort Value < IOValue . 
endfm

view Value0 from DEFAULT to LANG-AST is
    sort Elt to Value .
    op 0 to delete .
endv

view Value from TRIV to LANG-AST is
    sort Elt to Value .
endv

view IOValue from TRIV to LANG-AST is
    sort Elt to IOValue .
endv

---(
    Definition of how the language is interpreted
)
fmod LANG-SEMANTICS is
    protecting LANG-AST .
    protecting CONVERSION .
    protecting ARRAY{Nat, Value0} .
    protecting MAP{String, IOValue} .
    protecting LIST{IOValue} .
    
    sort State .

    --- inner state of the execution. Stores defined functions and variables. CallStack is not used anymore
    op [_|_|_] : FuncStorage VarStorage Stack -> State [ctor prec 50 gather (e e &)] .

    sort FuncStorage .
    sort Func .
    subsort Func < FuncStorage .

    op empty : -> FuncStorage [ctor] .
    op _;_ : FuncStorage FuncStorage -> FuncStorage [ctor comm assoc id: empty prec 45] . 

    op func(_,_,_) : String FuncParams StmtAST -> Func [ctor format (b b b b b b b b o)] .

    sort StoredVar .
    sort VarStorage .
    subsort StoredVar < VarStorage .

    op empty : -> VarStorage [ctor] .
    op _;_ : VarStorage VarStorage -> VarStorage [ctor comm assoc id: empty prec 45] .
    
    --- storing index of a variable on the stack
    op _:=_ : String Nat -> StoredVar [ctor] .
    --- storing returned value from a function
    op returnVal : Value -> StoredVar [ctor] .

    sort Stack .
    op stack : Nat Array{Nat, Value0} -> Stack [ctor] .

    --- result from evaluation of a code (left contains value of evaluated expression, right is resulting state)
    sort EvalResult .
    op {_,_} : Value State -> EvalResult [ctor] .

    var V V' : Value .
    var St St' : State .

    --- instead of making it return exact sort, we return the kind of the sort.
    --- this prevents derivations of the operators until they return an actual Value/State
    op getValue : EvalResult -> [Value] .
    eq getValue({V, St}) = V .

    op getState : EvalResult -> [State] .
    eq getState({V, St}) = St .

    var I : Int .

    op isInt : Value -> Bool .
    eq isInt(intVal(I)) = true .
    eq isInt(V) = false [owise] .

    op isInt : EvalResult -> Bool .
    eq isInt({V, St}) = isInt(V) .

    op getInt : Value -> Int .
    eq getInt(intVal(I)) = I .

    var STR : String .
    
    op isStr : Value -> Bool .
    eq isStr(strVal(STR)) = true .
    eq isStr(V) = false [owise] .

    op isStr : EvalResult -> Bool .
    eq isStr({V, St}) = isStr(V) .

    op getStr : Value -> String .
    eq getStr(strVal(STR)) = STR .

    var B : Bool .

    op isBool : Value ~> Bool .
    eq isBool(boolVal(B)) = true .


    op getBool : Value ~> Bool .
    eq getBool(boolVal(B)) = B .

    var F : Float .

    op isFloat : Value -> Bool .
    eq isFloat(floatVal(F)) = true .
    eq isFloat(V) = false [owise] .

    op isFloat : EvalResult -> Bool .
    eq isFloat({V, St}) = isFloat(V) .

    op getFloat : Value -> Float .
    eq getFloat(floatVal(F)) = F .
    eq getFloat(intVal(I)) = toFloat(I) .

    op isNum : EvalResult -> Bool .
    eq isNum({V, St}) = isFloat(V) or isInt(V) .

    op toFloat : Float -> Float .
    op toFloat : Int -> Float .
    eq toFloat(F) = F .
    eq toFloat(I) = float(I) .

    var N : Nat .
    var N' : Nat .
    
    var DICTARR : Dictionary .
    var LISTARR : RefList .

    op isRef : Value -> Bool .
    eq isRef(refVal(N)) = true .
    eq isRef(listVal(LISTARR)) = true .
    eq isRef(dictVal(DICTARR)) = true .
    eq isRef(V) = false [owise] .

    op isRef : EvalResult -> Bool .
    eq isRef({V, St}) = isRef(V) .

    op getRef : Value -> Nat .
    eq getRef(refVal(N)) = N .

    op isList : Value -> Bool .
    eq isList(listVal(LISTARR)) = true .
    eq isList(V) = false [owise] .

    op getList : Value -> RefList .
    eq getList(listVal(LISTARR)) = LISTARR .

    op getLength : Value -> Nat .
    eq getLength(listVal(LISTARR)) = length(LISTARR) .


    op isDict : Value -> Bool .
    eq isDict(dictVal(DICTARR)) = true .
    eq isDict(V) = false [owise] .

    op getDict : Value -> Dictionary .
    eq getDict(dictVal(DICTARR)) = DICTARR .


    vars E E1 : ExprAST .
    vars S S1 : StmtAST .

    --- evaluation of an expression with resulting value
    op evalExpr : ExprAST State -> [EvalResult] .
    --- evaluation of reference value
    op evalRefExpr : ExprAST State -> [EvalResult] .
    --- evaluation of a statement without result
    op evalStmt : StmtAST State -> [EvalResult] .

    sort CallStack .
    subsort State < CallStack .
    op empty : -> CallStack [ctor] .
    op aborted : VarStorage ~> State [ctor] .
    op error : String ~> State [ctor] .
    op locked : State Nat IO ~> State [ctor] .
    op dispatched : EvalResult IOValue IO ~> EvalResult [ctor] .

    op list : List{IOValue} -> IOValue .
    op map : Map{String, IOValue} -> IOValue .

    op toIO : Value State -> IOValue .
    ceq toIO(V, St) = V if not isRef(V) .
    eq toIO(listVal(LISTARR), St) = list(substackList(St, LISTARR)) .
    eq toIO(dictVal(DICTARR), St) = map(toMap(DICTARR, St)) .

    op toMap : Dictionary State -> Map{String, IOValue} .
    eq toMap(d(STR, N) ; DICTARR , St) = (STR |-> toIO(getStackValue(N, St), St)) , toMap(DICTARR, St) .
    eq toMap(empty , St) = empty .

    var IOVAL IOVAL' : IOValue .
    var IOLIST : List{IOValue} .
    var IOMAP : Map{String, IOValue} .

    op getIoList : IOValue -> List{IOValue} .
    eq getIoList(list(IOLIST)) = IOLIST .

    op getMap : IOValue -> Map{String, IOValue} .
    eq getMap(map(IOMAP)) = IOMAP .

    op toVal : IOValue State -> EvalResult .
    eq toVal(V, St) = {V, St} .
    eq toVal(list(nil), St) = { listVal(emptyList), St } .
    eq toVal(list(IOVAL IOLIST), St) = { 
        listVal(
            lastIndex(getStack(getState(toVal(IOVAL, St)))), 
            getList(getValue(toVal(
                list(IOLIST), 
                pushStack(getValue(toVal(IOVAL, St)), getState(toVal(IOVAL, St)))
            )))
        ), 
        getState(toVal(
            list(IOLIST), 
            pushStack(getValue(toVal(IOVAL, St)), getState(toVal(IOVAL, St)))
        )) 
    } .

    eq toVal(map(empty), St) = { dictVal(empty), St } .
    eq toVal(map((STR |-> IOVAL , IOMAP)), St) = { 
        dictVal(
            d(STR, lastIndex(getStack(getState(toVal(IOVAL, St))))) ;
            getDict(getValue(toVal(
                map(IOMAP), 
                pushStack(getValue(toVal(IOVAL, St)), getState(toVal(IOVAL, St)))
            )))
        ), 
        getState(toVal(
            map(IOMAP), 
            pushStack(getValue(toVal(IOVAL, St)), getState(toVal(IOVAL, St)))
        )) 
    } .

    --- if statement is just an expression evaluate it
    eq evalStmt(E, St) = evalExpr(E, St) .

    --- evaluate addition as integer addition if both values are integers
    ceq evalExpr($add(E, E1), St) = { intVal(getInt(getValue(evalExpr(E, St))) + getInt(getValue(evalExpr(E1, St)))), St }
        if isInt(evalExpr(E, St)) and isInt(evalExpr(E1, St)) .
    ceq evalExpr($sub(E, E1), St) = { intVal(getInt(getValue(evalExpr(E, St))) - getInt(getValue(evalExpr(E1, St)))), St }
        if isInt(evalExpr(E, St)) and isInt(evalExpr(E1, St)) .
    ceq evalExpr($mult(E, E1), St) = { intVal(getInt(getValue(evalExpr(E, St))) * getInt(getValue(evalExpr(E1, St)))), St }
        if isInt(evalExpr(E, St)) and isInt(evalExpr(E1, St)) .
    ceq evalExpr($div(E, E1), St) = { floatVal(toFloat(getInt(getValue(evalExpr(E, St)))) / toFloat(getInt(getValue(evalExpr(E1, St))))), St }
        if isInt(evalExpr(E, St)) and isInt(evalExpr(E1, St)) .
    ceq evalExpr($neg(E), St) = { intVal(- getInt(getValue(evalExpr(E, St)))), St }
        if isInt(evalExpr(E, St)) .
        
    ceq evalExpr($add(E, E1), St) = { floatVal(toFloat(getFloat(getValue(evalExpr(E, St)))) + toFloat(getFloat(getValue(evalExpr(E1, St))))), St }
        if (isFloat(evalExpr(E, St)) and isNum(evalExpr(E1, St))) or (isFloat(evalExpr(E1, St)) and isNum(evalExpr(E, St))) .
    --- ceq evalExpr($sub(E, E1), St) = { floatVal(toFloat(getFloat(getValue(evalExpr(E, St)))) - toFloat(getFloat(getValue(evalExpr(E1, St))))), St }
    ---     if (isFloat(evalExpr(E, St)) and isNum(evalExpr(E1, St))) or (isFloat(evalExpr(E1, St)) and isNum(evalExpr(E, St))) .
    ceq evalExpr($mult(E, E1), St) = { floatVal(toFloat(getFloat(getValue(evalExpr(E, St)))) * toFloat(getFloat(getValue(evalExpr(E1, St))))), St }
        if (isFloat(evalExpr(E, St)) and isNum(evalExpr(E1, St))) or (isFloat(evalExpr(E1, St)) and isNum(evalExpr(E, St))) .
    ceq evalExpr($div(E, E1), St) = { floatVal(toFloat(getFloat(getValue(evalExpr(E, St)))) / toFloat(getFloat(getValue(evalExpr(E1, St))))), St }
        if (isFloat(evalExpr(E, St)) and isNum(evalExpr(E1, St))) or (isFloat(evalExpr(E1, St)) and isNum(evalExpr(E, St))) .

    ceq evalExpr($add(E, E1), St) = { strVal(getStr(getValue(evalExpr(E, St))) + getStr(getValue(evalExpr(E1, St)))), St }
        if isStr(evalExpr(E, St)) and isStr(evalExpr(E1, St)) .

    eq evalExpr($eq(E, E1), St) = { boolVal(getValue(evalExpr(E, St)) == getValue(evalExpr(E1, St))), St } .
    
    eq evalExpr($ne(E, E1), St) = { boolVal(getValue(evalExpr(E, St)) =/= getValue(evalExpr(E1, St))), St } .
    
    ceq evalExpr($lt(E, E1), St) = { boolVal(getInt(getValue(evalExpr(E, St))) < getInt(getValue(evalExpr(E1, St)))), St }
        if isInt(evalExpr(E, St)) and isInt(evalExpr(E1, St)) .
    
    ceq evalExpr($gt(E, E1), St) = { boolVal(getInt(getValue(evalExpr(E, St))) > getInt(getValue(evalExpr(E1, St)))), St }
        if isInt(evalExpr(E, St)) and isInt(evalExpr(E1, St)) .
    
    ceq evalExpr($ge(E, E1), St) = { boolVal(getInt(getValue(evalExpr(E, St))) >= getInt(getValue(evalExpr(E1, St)))), St }
        if isInt(evalExpr(E, St)) and isInt(evalExpr(E1, St)) .

    eq evalExpr($and(E, E1), St) = { boolVal(getBool(getValue(evalExpr(E, St))) and getBool(getValue(evalExpr(E1, getState(evalExpr(E, St)))))), getState(evalExpr(E1, getState(evalExpr(E, St)))) } .
    eq evalExpr($or(E, E1), St) = { boolVal(getBool(getValue(evalExpr(E, St))) or getBool(getValue(evalExpr(E1, getState(evalExpr(E, St)))))), getState(evalExpr(E1, getState(evalExpr(E, St)))) } .


    var VARS VARS' : VarStorage .
    var FUNCS : FuncStorage .
    vars PARAMS PARAMS' : FuncParams .
    var ARGS : CallArgs .
    var STACK : Stack .
    
    var DICT : DictEntryListAST .
    var DICTITEM : DictEntryAST .

    op validState : State -> Bool .
    eq validState([ FUNCS | VARS | STACK ]) = valid(VARS) .
    --- eq validState(locked(St, N)) = validState(St) .

    op valid : VarStorage -> Bool .
    ceq valid(VARS ; VARS') = valid(VARS) and valid(VARS') if VARS =/= empty and VARS' =/= empty .
    eq valid(STR := N) = true .
    eq valid(returnVal(V)) = true .
    eq valid(empty) = true .
    
    op getVars : State -> VarStorage .
    eq getVars([ FUNCS | VARS | STACK ]) = VARS .


    ceq evalRefExpr(index(E, E1), St) = { 
        refVal(
            listItem(
                getList(getStackValue(getRef(getValue(evalRefExpr(E, St))), getState(evalRefExpr(E, St)))),
                getInt(getValue(evalExpr(E1, getState(evalRefExpr(E, St)))))
            )
        ), 
        getState(evalExpr(E1, getState(evalRefExpr(E, St)))) 
    }
    if isList(getStackValue(getRef(getValue(evalRefExpr(E, St))), getState(evalRefExpr(E, St))))
        /\ getLength(getStackValue(getRef(getValue(evalRefExpr(E, St))), getState(evalRefExpr(E, St)))) > getInt(getValue(evalExpr(E1, getState(evalRefExpr(E, St)))))
    .

    ceq evalRefExpr(index(E, E1), St) = evalRefExpr(member(E, getStr(getValue(evalExpr(E1, getState(evalRefExpr(E, St)))))), getState(evalExpr(E1, getState(evalRefExpr(E, St)))))
    if isDict(getStackValue(getRef(getValue(evalRefExpr(E, St))), getState(evalRefExpr(E, St))))
        /\ isStr(getValue(evalExpr(E1, getState(evalRefExpr(E, St)))))
    .


    op evalClone : ExprAST State ~> EvalResult .
    eq evalClone(E, St) = {
        getValue(clone(getRef(getValue(evalRefExpr(E, St))), getState(evalRefExpr(E, St)))),
        getState(clone(getRef(getValue(evalRefExpr(E, St))), getState(evalRefExpr(E, St))))
    } .

    op clone : Nat State ~> EvalResult .
    eq clone(N, St) = cloneValue(getStackValue(N, St), St) .

    op cloneValue : Value State ~> EvalResult .
    ceq cloneValue(V, St) = { V, St } if not isRef(V) /\ validState(St) .
    eq cloneValue(listVal(emptyList), St) = { listVal(emptyList), St } .
    eq cloneValue(listVal(N, LISTARR), St) = { 
        listVal(
            lastIndex(getStack(getState(clone(N, St)))), 
            getList(getValue(cloneValue(
                listVal(LISTARR), 
                pushStack(getValue(clone(N, St)), getState(clone(N, St)))
            )))
        ), 
        getState(cloneValue(
            listVal(LISTARR), 
            pushStack(getValue(clone(N, St)), getState(clone(N, St)))
        )) 
    } .
    
    eq cloneValue(dictVal(empty), St) = { dictVal(empty), St } .
    eq cloneValue(dictVal(d(STR, N) ; DICTARR), St) = { 
        dictVal(
            d(STR, lastIndex(getStack(getState(clone(N, St))))) ;
            getDict(getValue(cloneValue(
                dictVal(DICTARR), 
                pushStack(getValue(clone(N, St)), getState(clone(N, St)))
            )))
        ), 
        getState(cloneValue(
            dictVal(DICTARR), 
            pushStack(getValue(clone(N, St)), getState(clone(N, St)))
        )) 
    } .

    ceq evalRefExpr(member(E, STR), St) = {
        refVal(
            getDict(getStackValue(
                getRef(getValue(evalRefExpr(E, St))), 
                getState(evalRefExpr(E, St))
            )) [ STR ]
        ),
        getState(evalRefExpr(E, St))
    } if hasMapping(getDict(getStackValue(
                getRef(getValue(evalRefExpr(E, St))), 
                getState(evalRefExpr(E, St))
            )), STR) .

    ceq evalRefExpr(member(E, STR), St) = {
        refVal(
            lastIndex(getStack(getState(evalRefExpr(E, St))))
        ),
        assignValue(
            getRef(getValue(evalRefExpr(E, St))),
            dictVal(getDict(getStackValue(getRef(getValue(evalRefExpr(E, St))), St)) ; d(STR, lastIndex(getStack(getState(evalRefExpr(E, St)))))),
            pushStack(void, getState(evalRefExpr(E, St)))
        )
    } if not hasMapping(getDict(getStackValue(
                getRef(getValue(evalRefExpr(E, St))), 
                getState(evalRefExpr(E, St))
            )), STR) .


    ceq evalExpr(member(E, STR), St) = evalClone(member(E, STR), St)
    if hasMapping(getDict(getStackValue(
                getRef(getValue(evalRefExpr(E, St))), 
                getState(evalRefExpr(E, St))
            )), STR) .

    ceq evalExpr(index(E, E1), St) = evalClone(index(E, E1), St)
    if 
        (
            isList(getStackValue(getRef(getValue(evalRefExpr(E, St))), getState(evalRefExpr(E, St))))
            and getLength(getStackValue(getRef(getValue(evalRefExpr(E, St))), getState(evalRefExpr(E, St)))) > getInt(getValue(evalExpr(E1, getState(evalRefExpr(E, St)))))
        ) or (
            isDict(getStackValue(getRef(getValue(evalRefExpr(E, St))), getState(evalRefExpr(E, St))))
            and isStr(getValue(evalExpr(E1, getState(evalRefExpr(E, St)))))
            and hasMapping(getDict(getStackValue(
                getRef(getValue(evalRefExpr(E, St))), 
                getState(evalRefExpr(E, St))
            )), getStr(getValue(evalExpr(E1, getState(evalRefExpr(E, St))))))
        )
    .

    --- retrieve value of the variable
    eq evalExpr(id(STR), [ FUNCS | STR := N ; VARS | STACK ]) = evalClone(id(STR), [ FUNCS | STR := N ; VARS | STACK ]) .
    --- integer literal
    eq evalExpr(int(I), St) = { intVal(I), St } .
    --- string literal
    eq evalExpr(str(STR), St) = { strVal(STR), St } .

    eq evalExpr(float(F), St) = { floatVal(F), St } .
    eq evalExpr(bool(B), St) = { boolVal(B), St } .

    --- evaluate second statement based on the resulting state of previous statement
    ceq evalStmt(S ; S1, St) = evalStmt(S1, getState(evalStmt(S, St))) if S =/= pass and S1 =/= pass and validState(St) .
    eq evalStmt(pass, St) = { void, St }  .

    --- variable assignment
    ceq evalStmt(assign(E, E1), St) = evalAssign(E, evalExpr(E1, St)) if validState(St) .

    op evalAssign : ExprAST EvalResult ~> EvalResult .
    eq evalAssign(E, { V, St }) = { void, assignValue(getRef(getValue(evalRefExpr(E, St))), V, getState(evalRefExpr(E, St))) } .

    --- function return
    eq evalStmt(return(E), St) = evalReturn(evalExpr(E, St)) .

    op evalReturn : EvalResult ~> EvalResult .
    eq evalReturn({V, [ FUNCS | returnVal(V') ; VARS | STACK ]}) = { void, [ FUNCS | returnVal(V) ; VARS | STACK ] } .
    eq evalReturn({V, [ FUNCS | VARS | STACK ]}) = { void, [ FUNCS | returnVal(V) ; VARS | STACK ] } [owise] .

    --- function definition
    ceq evalStmt(function(STR, PARAMS, S), [ func(STR, PARAMS', S1) ; FUNCS | VARS | STACK ]) = { void, [ func(STR, PARAMS, S) ; FUNCS | VARS | STACK ] } if validState([ func(STR, PARAMS', S1) ; FUNCS | VARS | STACK ]) .
    ceq evalStmt(function(STR, PARAMS, S), [ FUNCS | VARS | STACK ]) = { void, [ func(STR, PARAMS, S) ; FUNCS | VARS | STACK ] } if validState([ FUNCS | VARS | STACK ]) [owise] .

    --- function call

    ceq evalExpr(call(STR, ARGS), [ func(STR, PARAMS, S) ; FUNCS | VARS | STACK ]) = 
        functionCallResult(PARAMS, [ func(STR, PARAMS, S) ; FUNCS | VARS | STACK ], evalStmt(
            S,
            addArgs(ARGS, PARAMS, [ func(STR, PARAMS, S) ; FUNCS | VARS | STACK ])
        )) 
    if validState([ func(STR, PARAMS, S) ; FUNCS | VARS | STACK ]) .

    ceq evalExpr(call("len", args(E)), St) = {
        intVal(length(getList(getValue(evalExpr(E, St))))),
        getState(evalExpr(E, St))
    } 
    if isList(getValue(evalExpr(E, St))) .

    ceq evalExpr(call("append", args(E, E1)), St) = {
        listVal(getList(getValue(evalExpr(E, St))), lastIndex(getStack(getState(evalExpr(E1, getState(evalExpr(E, St))))))),
        pushStack(getValue(evalExpr(E1, getState(evalExpr(E, St)))), getState(evalExpr(E1, getState(evalExpr(E, St)))))
    } 
    if isList(getValue(evalExpr(E, St))) .
    
    ceq evalExpr(call("keyExists", args(E, E1)), St) = {
        boolVal(hasMapping(getDict(getValue(evalExpr(E, St))), getStr(getValue(evalExpr(E1, getState(evalExpr(E, St))))))),
        getState(evalExpr(E1, getState(evalExpr(E, St))))
    } 
    if isDict(getValue(evalExpr(E, St))) .

    --- ceq evalExpr(call("keys", args(E, E1)), St) = {
    ---     listVal(hasMapping(getDict(getValue(evalExpr(E, St))), getStr(getValue(evalExpr(E1, getState(evalExpr(E, St))))))),
    ---     getState(evalExpr(E1, getState(evalExpr(E, St))))
    --- } 
    --- if isDict(getValue(evalExpr(E, St))) .

    var RES : EvalResult .

    op functionCallResult : FuncParams State EvalResult -> [EvalResult] .
    ceq functionCallResult(PARAMS, [ FUNCS | VARS | STACK ], {V, St}) ={ 
        getReturnValue({V, St}),
        [ FUNCS
        --- rollback variables (no globals)
        | VARS
        | getStack(St)
        ]
    } if validState(St) .

    ceq evalStmt($while(E, S), St) = (if getBool(getValue(evalExpr(E, St))) then 
        evalStmt($while(E, S), getState(evalStmt(S, St)))
    else
        evalStmt(pass, St)
    fi) 
    if isBool(getValue(evalExpr(E, St))) .

    ceq evalStmt($ifelse(E, S, S1), St) = (if getBool(getValue(evalExpr(E, St))) then 
        evalStmt(S, St) 
    else 
        evalStmt(S1, St)
    fi)
    if isBool(getValue(evalExpr(E, St))) .

    --- program abortion
    eq evalExpr(S, aborted(VARS)) = { void, aborted(VARS) } .
    eq evalStmt(S, aborted(VARS)) = { void, aborted(VARS) } .
    eq evalStmt(abort, St) = { void, aborted(getVars(St)) } .

    var Io : IO .
    eq evalStmt($lock(E, Io), St) = { void, locked(getState(evalRefExpr(E, St)), getRef(getValue(evalRefExpr(E, St))), Io) } .

    eq evalStmt($dispatch(E, Io), St) = evalDispatch(evalExpr(E, St), Io).

    op evalDispatch : EvalResult IO ~> EvalResult .
    eq evalDispatch({V, St}, Io) = dispatched({ void, St }, toIO(V, St), Io) .

    op getReturnValue : EvalResult -> [Value] .
    eq getReturnValue({ void, [ FUNCS | returnVal(V) ; VARS | STACK ] }) = V .
    eq getReturnValue({ void, aborted(VARS) }) = void .
    eq getReturnValue({ V, St }) = void [owise] .


    var ARG : ArgAST .
    var ARGLIST : ArgListAST .
    var PARAM : ParamAST .
    var PARAMLIST : ParamListAST .

    eq evalExpr(list(E, ARGLIST), [ FUNCS | VARS | STACK ]) = { 
        listVal(
            lastIndex(getStack(getState(evalExpr(E, [ FUNCS | VARS | STACK ])))), 
            getList(getValue(evalExpr(
                list(ARGLIST), 
                pushStack(
                    getValue(evalExpr(E, [ FUNCS | VARS | STACK ])), 
                    getState(evalExpr(E, [ FUNCS | VARS | STACK ]))
                )
            )))
        ), 
        getState(evalExpr(
            list(ARGLIST), 
            pushStack(
                getValue(evalExpr(E, [ FUNCS | VARS | STACK ])), 
                getState(evalExpr(E, [ FUNCS | VARS | STACK ]))
            )
        )) 
    } .
    eq evalExpr(list(empty), [ FUNCS | VARS | STACK ]) = { listVal(emptyList), [ FUNCS | VARS | STACK ] } .


    eq evalExpr(dict(dictItem(id(STR), E), DICT), [ FUNCS | VARS | STACK ]) = { 
        dictVal(
            d(STR, lastIndex(getStack(getState(evalExpr(E, [ FUNCS | VARS | STACK ]))))) ; 
            getDict(getValue(
                evalExpr(dict(DICT), [ FUNCS | VARS | pushStack(getValue(evalExpr(E, [ FUNCS | VARS | STACK ])), getStack(getState(evalExpr(E, [ FUNCS | VARS | STACK ])))) ])
            ))
        ), getState(evalExpr(dict(DICT), [ FUNCS | VARS | pushStack(getValue(evalExpr(E, [ FUNCS | VARS | STACK ])), getStack(getState(evalExpr(E, [ FUNCS | VARS | STACK ])))) ])) } .

    eq evalExpr(dict(emptyDict), St) = { dictVal(empty) , St } .

 

    eq evalRefExpr(id(STR), [ FUNCS | STR := N ; VARS | STACK ]) = { refVal(N), [ FUNCS | STR := N ; VARS | STACK ] } .
    eq evalRefExpr(id(STR), [ FUNCS | VARS | STACK ]) = { refVal(lastIndex(STACK)), [ FUNCS | STR := lastIndex(STACK) ; VARS | pushStack(void, STACK) ] } [owise] .


    --- assigning variables for function call
    op assignVar : String ExprAST State -> State .
    eq assignVar(STR, E, St) = getState(evalAssign(id(STR), evalExpr(E, St))) .

    op assignVar : String Value State -> State .
    eq assignVar(STR, V, [ FUNCS | STR := N ; VARS | STACK ]) = 
        [ FUNCS 
        | STR := lastIndex(STACK) ; VARS 
        | pushStack(V, STACK)
        ] .
    eq assignVar(STR, V, [ FUNCS | VARS | STACK ]) = 
        [ FUNCS 
        | STR := lastIndex(STACK) ; VARS 
        | pushStack(V, STACK)
        ] [owise] .

    op addArgs : CallArgs FuncParams State -> State .
    eq addArgs(args(E, ARGLIST), params(id(STR), PARAMLIST), St) = addArgs(args(ARGLIST), params(PARAMLIST), assignVar(STR, E, St)) .
    eq addArgs(args(empty), params(empty), St) = St .

    vars ARR ARR' : Array{Nat, Value0} .

    op assignValue : Nat Value State -> State .
    eq assignValue(N, V, [ FUNCS | VARS | STACK ]) = 
        [ FUNCS | VARS | assignValue(N, V, STACK) ] .

    op assignValue : Nat Value Stack -> Stack .
    ceq assignValue(N, V, stack(N', ARR)) = 
        stack(N', insert(N, V, ARR))
    if N < N' .

    vars IND LEN : Nat . 

    op pushStack : Stack Nat Nat Stack -> Stack .
    eq pushStack(stack(N, ARR), IND, 0, STACK) = STACK .
    eq pushStack(stack(N, ARR), IND, s(LEN), STACK) = pushStack(stack(N, ARR), s(IND), LEN, assignValue(lastIndex(STACK), ARR[IND], pushStack(void, STACK))) .

    op pushStack : Value Stack -> Stack .
    eq pushStack(V, stack(N', ARR)) = stack(N' + 1, insert(N', V, ARR)) .
    
    op pushStack : Value State -> State .
    eq pushStack(V, [ FUNCS | VARS | STACK ]) = [ FUNCS | VARS | pushStack(V, STACK) ] .

    op getStackValue : Nat State -> Value .
    eq getStackValue(N, [ FUNCS | VARS | stack(N', ARR) ]) = ARR [ N ] .

    op getStackValue : Nat Stack -> Value .
    eq getStackValue(N, stack(N', ARR)) = ARR [ N ] .

    op lastIndex : Stack -> Nat .
    eq lastIndex(stack(N, ARR)) = N .

    op substackList : State RefList -> List{IOValue} .
    eq substackList(St, (N, LISTARR)) = toIO(getStackValue(N, St), St) substackList(St, LISTARR) .
    eq substackList(St, emptyList) = nil .

    op getStack : State -> Stack .
    eq getStack([ FUNCS | VARS | STACK ]) = STACK .

    op getStackArr : Stack -> Array{Nat, Value0} .
    eq getStackArr(stack(N, ARR)) = ARR .

    var ~RES : [EvalResult] .
    var ~St : [State] .
    var ~V : [Value] .
    op unlock : EvalResult Value -> [EvalResult] .
    op unlockState : State Value -> [State] .
    
    eq unlock(functionCallResult(PARAMS, St, ~RES), IOVAL) = functionCallResult(PARAMS, St, unlock(~RES, IOVAL)) .
    eq unlock(evalStmt(S, ~St), IOVAL) = evalStmt(S, unlockState(~St, IOVAL)) .
    eq unlock(evalExpr(E, ~St), IOVAL) = evalExpr(E, unlockState(~St, IOVAL)) .
    eq unlock(evalAssign(E, ~RES), IOVAL) = evalAssign(E, unlock(~RES, IOVAL)) .
    eq unlock(evalReturn(~RES), IOVAL) = evalReturn(unlock(~RES, IOVAL)) .
    eq unlock({~V, ~St}, IOVAL) = {~V, unlockState(~St, IOVAL)} .

    eq unlockState(locked(St, N, Io), IOVAL) = assignValue(N, getValue(toVal(IOVAL, St)), getState(toVal(IOVAL, St))) .
    eq unlockState(getState(~RES), IOVAL) = getState(unlock(~RES, IOVAL)) .
    eq unlockState(addArgs(args(ARGLIST), params(PARAMLIST), ~St), IOVAL) = addArgs(args(ARGLIST), params(PARAMLIST), unlockState(~St,IOVAL)) .



    eq functionCallResult(PARAMS, St', dispatched(~RES, IOVAL, Io)) = dispatched(functionCallResult(PARAMS, St', ~RES), IOVAL, Io) .
    eq evalStmt(S, getState(dispatched(~RES, IOVAL, Io))) = dispatched(evalStmt(S, getState(~RES)), IOVAL, Io) .
    eq evalAssign(E, dispatched(~RES, IOVAL, Io)) = dispatched(evalAssign(E, ~RES), IOVAL, Io) .
    eq {~V, getState(dispatched(~RES, IOVAL, Io))} = dispatched({~V, getState(~RES)}, IOVAL, Io) .
endfm

fmod LANG-ERRORS is

    protecting LANG-SEMANTICS .

    op getError : [EvalResult] -> String .

    var ~RES : [EvalResult] .

    eq getError(~RES) = "Unknown Error" [owise] .
endfm

---(
    Utility module for checking if a token is a valid identifier
)
fmod IDENTIFIER is 
    protecting STRING .
    protecting BOOL .

    var S : String .

    op valid : String -> Bool .
    eq valid(S) = startsWithLetter(S) and onlyValidChars(S) .

    op startsWithLetter : String -> Bool .
    eq startsWithLetter(S) = (ascii(substr(S, 0, 1)) >= ascii("A") and ascii(substr(S, 0, 1)) <= ascii("Z"))
                            or (ascii(substr(S, 0, 1)) >= ascii("a") and ascii(substr(S, 0, 1)) <= ascii("z"))
     .

    op onlyValidChars : String -> Bool .
    ceq onlyValidChars(S) = validChar(substr(S, 0, 1)) and onlyValidChars(substr(S, 1, length(S))) 
        if S =/= "" .
    eq onlyValidChars("") = true .

    op validChar : Char -> Bool .
    eq validChar(S) = startsWithLetter(S) or (S == "_") or (ascii(S) >= ascii("0") and ascii(S) <= ascii("9")).
endfm


---(
    This module converts parsed structure of terms (from LANG-SYNTAX) into AST
)
fmod LANG is
    protecting META-LEVEL .
    protecting LANG-AST .
    protecting STRING .
    protecting IDENTIFIER .

    protecting LEXICAL .

    vars T T1 T2 : Term .
    vars Q Q1 Q2 : Qid .

    op process : Term ~> AST .

    ceq process('token[T]) = int(downTerm(getTerm(parsePredefined(T, 'INT, 'Int)), 0)) 
    if parsePredefined(T, 'INT, 'Int) :: ResultPair .

    ceq process('token[T]) = float(downTerm(getTerm(parsePredefined(T, 'FLOAT, 'Float)), 0.0)) 
    if parsePredefined(T, 'FLOAT, 'Float) :: ResultPair .

    ceq process('token[T]) = str(downTerm(getTerm(parsePredefined(T, 'STRING, 'String)), "")) 
    if parsePredefined(T, 'STRING, 'String) :: ResultPair .

    ceq process('token[T]) = id(string(downTerm(T, '$err))) 
    if valid(string(downTerm(T, '$err))) .

    eq process('true.Expr) = bool(true) .
    eq process('false.Expr) = bool(false) .

    eq process('_+_[T, T1]) = $add(process(T), process(T1)) .
    eq process('_-_[T, T1]) = $sub(process(T), process(T1)) .
    eq process('_*_[T, T1]) = $mult(process(T), process(T1)) .
    eq process('_/_[T, T1]) = $div(process(T), process(T1)) .
    eq process('-_[T]) = $neg(process(T)) .
    eq process('_==_[T, T1]) = $eq(process(T), process(T1)) .
    eq process('_!=_[T, T1]) = $ne(process(T), process(T1)) .
    eq process('_>_[T, T1]) = $gt(process(T), process(T1)) .
    eq process('_>=_[T, T1]) = $ge(process(T), process(T1)) .
    eq process('_<_[T, T1]) = $lt(process(T), process(T1)) .
    eq process('_<=_[T, T1]) = $le(process(T), process(T1)) .
    eq process('_&&_[T, T1]) = $and(process(T), process(T1)) .
    eq process('_||_[T, T1]) = $or(process(T), process(T1)) .
    eq process('!_[T]) = $eq(process(T), bool(false)) .

    eq process('`(_`)[T]) = process(T) .
    eq process('_;[T]) = process(T) .

    eq process('_=_;[T, T1]) = assign(process(T), process(T1)) .
    eq process('pass`;.Stmt) = pass .
    eq process('return_;[T]) = return(process(T)) .

    eq process('__[T, T1]) = process(T) ; process(T1) .

    eq process('function_`(`)`{_`}[T, T1]) = function(extractId(process(T)), params(empty), process(T1)) .
    eq process('function_`(_`)`{_`}[T, T1, T2]) = function(extractId(process(T)), params(processParams(T1)), process(T2)) .
    eq process('_`(`)[T]) = call(extractId(process(T)), args(empty)) .
    eq process('_`(_`)[T, T1]) = call(extractId(process(T)), args(processArgs(T1))) .

    eq process('while_`{_`}[T, T1]) = $while(process(T), process(T1)) .
    eq process('if_`{_`}[T, T1]) = $ifelse(process(T), process(T1), pass) .
    eq process('if_`{_`}else`{_`}[T, T1, T2]) = $ifelse(process(T), process(T1), process(T2)) .

    eq process('`[_`][T]) = list(processArgs(T)) .
    eq process('`[`].Expr) = list(empty) .
    eq process('_`[_`][T, T1]) = index(process(T), process(T1)) .

    op processArgs : Term ~> ArgListAST .
    eq processArgs(T) = process(T) [owise] .
    eq processArgs('_`,_[T, T1]) = processArgs(T) , processArgs(T1) .

    op processParams : Term ~> ParamListAST .
    eq processParams(T) = process(T) [owise] .
    eq processParams('_`,_[T, T1]) = processParams(T) , processParams(T1) .

    eq process('`{_`}[T]) = dict(processDict(T)) .
    eq process('`{`}.Expr) = dict(emptyDict) .
    eq process('_._[T, T1]) = member(process(T), extractId(process(T1))) .

    op processDict : Term ~> DictEntryListAST .
    eq processDict('_`,_[T, T1]) = processDict(T), processDict(T1) .
    eq processDict('_:_[T, T1]) = dictItem(process(T), process(T1)) .

    var STR : String .

    op extractId : AST ~> String .
    eq extractId(id(STR)) = STR . 

    op parsePredefined : Qid Qid Qid -> ResultPair? .
    eq parsePredefined(Q2, Q, Q1) = metaParse(upModule(Q, false), downTerm(Q2, 'error), Q1) .


    vars ~CODE ~CODE' : [StmtAST] .
    var CODE CODE' : StmtAST .
    --- var STR : String .
    var PARAMS : FuncParams .
    var EXPR : ExprAST .
    var ~EXPR : [ExprAST] .
    var ~DICT : [DictEntryListAST] .
    var DICT DICT' : DictEntryListAST .


    op getLangProcessError : AST ~> QidList .
    eq getLangProcessError(~CODE) = 'Language '\s 'Error .
    --- ceq getLangProcessError(~CODE) = "Unknown Language Parse Error" if not ~CODE :: AST .
    --- ceq getLangProcessError(function(STR, PARAMS, ~CODE') ; ~CODE) = "Error in function " + STR + ": " + getLangProcessError(~CODE') if not ~CODE' :: AST .
    --- ceq getLangProcessError(CODE ; ~CODE ; CODE') = getLangProcessError(~CODE) if not ~CODE :: AST and CODE =/= pass and CODE' =/= pass . 

    --- ceq getLangProcessError(assign(EXPR, ~EXPR)) = "In assignment: " + getExprProcessError(~EXPR) if not ~EXPR :: ExprAST .

    --- op getExprProcessError : ExprAST ~> String .
    --- ceq getExprProcessError(dict(~DICT)) = "In dictionary: " + getDictProcessError(~DICT) if not ~DICT :: DictEntryListAST .
    --- ceq getExprProcessError(process('token[T])) = "Invalid token " + string(downTerm(T, '$err)) if not process('token[T]) :: AST .

    --- op getDictProcessError : DictEntryListAST ~> String .
    --- ceq getDictProcessError(DICT, ~DICT, DICT') = getDictProcessError(~DICT) if not ~DICT :: DictEntryListAST and DICT =/= emptyDict and DICT' =/= emptyDict .
    --- ceq getDictProcessError(dictItem(id(STR), ~EXPR)) = "In field " + STR + ": " + getExprProcessError(~EXPR) if not ~EXPR :: ExprAST .

endfm

load file.maude

view Oid from TRIV to CONFIGURATION is 
 sort Elt to Oid . 
endv
     
 
fmod MAYBE{X :: TRIV} is 
 sort Maybe{X} . 
 subsort X$Elt < Maybe{X} . 
 op maybe : -> Maybe{X} [ctor] . 
endfm

mod FILE-READER is
    protecting CONFIGURATION .
    protecting FILE .
    protecting MAYBE{Oid} .

    vars F S TEXT : String .
    var FHIn : Oid .
    var Attrs : AttributeSet .

    
    op Reader : -> Cid [ctor] .
    op reader : String -> Oid [ctor] .
    op result:_ : String -> Attribute [ctor] .
    op fhIn:_ : Maybe{Oid} -> Attribute [ctor] .
    op done:_ : Bool -> Attribute [ctor] .
    op fileName:_ : String -> Attribute [ctor] .

    op getFileContents : String ~> String .
    op extractReader : Configuration ~> String .

    op scanFile : String -> Msg [ctor] .
    op scannedFile : String String -> Msg [ctor] .

    op readerError : String String -> Msg [ctor] .

    eq getFileContents(S) = extractReader(scanFile(S)) .

    rl scanFile(S) => <> < reader(S) : Reader | result: "", fhIn: maybe, done: false, fileName: S > openFile(fileManager, reader(S), S, "r") .

    rl < reader(S) : Reader | fhIn: maybe, Attrs > openedFile(reader(S), fileManager, FHIn)
    =>
        < reader(S) : Reader | fhIn: FHIn, Attrs > getLine(FHIn, reader(S)) .

    rl < reader(F) : Reader | fhIn: FHIn, result: S, done: false, Attrs > gotLine(reader(F), FHIn, TEXT)
    =>
        if TEXT =/= "" then
            < reader(F) : Reader | fhIn: FHIn, result: (S + TEXT), done: false, Attrs > getLine(FHIn, reader(F))
        else
            < reader(F) : Reader | fhIn: maybe, result: S, done: true, Attrs >
            closeFile(FHIn, reader(F))
        fi
    .

    rl < reader(F) : Reader | result: TEXT, done: true, fileName: F, Attrs > closedFile(reader(F), FHIn) <>
    => scannedFile(F, TEXT)
    .

    rl < reader(F) : Reader | Attrs > fileError(reader(F), FHIn, TEXT)
    => readerError(F, TEXT) .

    var CONF : Configuration .

    eq extractReader(scannedFile(S, TEXT) CONF)
        = TEXT .
        
endm

fmod LANG-TEST-FUNCS is
    protecting LANG-SEMANTICS .


    op stdio : -> IO [ctor] .

    op funcs : -> FuncStorage .
    eq funcs = func("read", params(empty), $lock(id("res"), stdio) ; return(id("res")))
        ; func("write", params(id("s")), $dispatch(id("s"), stdio))
    .
endfm

---(
    Utility functions for easy execution
)
mod LANG-IO is
    protecting LANG .
    protecting LANG-SEMANTICS .
    protecting LANG-TEST-FUNCS .
    extending LEXICAL .
    protecting FILE-READER .

    vars S TEXT : String .
    var QID : Qid .
    var QIDS : QidList .
    var A : AST .

    op preParse : String ~> ResultPair? .
    eq preParse(S) = metaParse(upModule('LANG-SYNTAX, false), tokenize(S), 'TopLevel) .

    op parse : String ~> AST .
    eq parse(S) = process(getTerm(metaParse(upModule('LANG-SYNTAX, false), tokenize(S), 'TopLevel))) .

    op execute : String ~> EvalResult .
    eq execute(S) = evalStmt(parse(S), [funcs | empty | stack(0, empty) ]) .

    op executeFile : String ~> EvalResult .
    eq executeFile(S) = execute(getFileContents(S)) .
    
    var V : IOValue .
    op executeFile : String IOValue ~> EvalResult .
    eq executeFile(S, V) = unlock(execute(getFileContents(S)), V) .

    op parseFile : String ~> AST .
    eq parseFile(S) = parse(getFileContents(S)) .

    op executeAST : AST ~> EvalResult .
    eq executeAST(A) = evalStmt(A, [funcs | empty | stack(0, empty) ]) .
endm