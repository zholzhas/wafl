load lang.maude
load model-checker.maude

---(
    Definition of syntax for web services
)
fmod SERVER-SYNTAX is
    protecting STRING .
    protecting QID-LIST .

    including LANG-SYNTAX .
    
    --- service name
    sort ServiceName . 
    op name : Qid -> ServiceName 
        [special (id-hook Bubble     (1 1) 
                op-hook qidSymbol (<Qids> : ~> Qid)) ] .

    sort Component .

    op code`{_`} : TopLevel -> Component [ctor] .
    op routes {_} : Router -> Component [ctor] .
    op persistent_=_; : Token Expr -> Component [ctor] .

    sort Router .
    sort Route .
    subsort Route < Router .

    op _->_ : String Token -> Route [ctor gather (e e) prec 40] .

    op __ : Router Router -> Router [ctor assoc] . 

    sort ComponentList .
    subsort Component < ComponentList .

    op empty : -> ComponentList [ctor] .
    op __ : ComponentList ComponentList -> ComponentList [ctor comm assoc id: empty] .

    op service_{_} : Token ComponentList -> Service [ctor] .
    op init`{_`} : TopLevel -> Service [ctor] .
    op props`{_`} : TopLevel -> PropCode [ctor] .

    sorts Service ServiceList .
    subsort Service < ServiceList .
    op none : -> ServiceList [ctor] .
    op __ : ServiceList ServiceList -> ServiceList [ctor assoc comm id: none] .

    sort PropCode .
    subsort PropCode < ServiceList .
endfm

---(
    Inner structure and simulation of web servers
)
mod SERVER-AST is
    protecting LANG-SEMANTICS .
    protecting CONFIGURATION .
    protecting NAT .

    sort SemComponent .

    op code : StmtAST -> SemComponent [ctor] .
    op initialState : State -> SemComponent [ctor] .
    op routes : SemRouter -> SemComponent [ctor] .
    op persistent : String IOValue -> SemComponent [ctor] .

    sorts SemConnId SemConnection SemRequest SemResponse .
    subsort Nat < SemConnId .

    subsort SemConnection < Object .
    op connectionManager : Nat -> Object [ctor] .

    sort SemServiceId .
    subsort String < SemServiceId .

    op dummyConnection : -> SemConnection [ctor] .
    op connection : SemConnId SemServiceId SemServiceId SemRequest -> SemConnection [ctor] .
    op connection : SemConnId SemServiceId SemServiceId SemRequest SemResponse -> SemConnection [ctor] .

    op httpRequest : String IOValue -> SemRequest [ctor] .
    op response : IOValue -> SemResponse [ctor] .

    sort SemRouter .
    sort SemRoute .
    subsort SemRoute < SemRouter .

    op route : String String -> SemRoute [ctor] .

    op $noRoutes : -> SemRouter [ctor] .
    op _,_ : SemRouter SemRouter -> SemRouter [ctor comm assoc id: $noRoutes] . 


    sort SemComponentList .
    subsort SemComponent < SemComponentList .

    op $empty : -> SemComponentList [ctor] .
    op _,_ : SemComponentList SemComponentList -> SemComponentList [ctor comm assoc id: $empty] .

    sort SemServer .
    op server : SemComponentList -> SemServer [ctor] .

    sort SemService .
    subsort SemService < Object .
    op service : SemServiceId SemServer -> SemService [ctor object] .

    op initManager : Nat -> Object [ctor] .
    op init : StmtAST -> SemService [ctor] .
    op initId : Nat -> SemServiceId [ctor] .
    op $cli : -> SemServiceId [ctor] .
endm

---(
    conversion from syntax to semantics
)
mod SERVER is
    protecting (LANG + LANG-IO) * (op process : Term ~> AST to processLang) .
    protecting SERVER-AST .
    protecting STRING .
    protecting LANG-ERRORS .

    vars T T1 T2 : Term .
    var TL TL1 : TermList .
    var QIDS : QidList .

    sort SemComponentList? .
    subsort SemComponentList < SemComponentList? .

    op compositionError : String -> SemComponentList? .

    op processComponents : TermList ~> SemComponentList? .
    eq processComponents('empty.ComponentList) = $empty .
    eq processComponents('__[T, TL]) = processComponents(T), processComponents(TL) .

    ceq processComponents('code`{_`}[T]) = code(processLang(T)) if processLang(T) :: StmtAST .
    ceq processComponents('code`{_`}[T]) = compositionError("Error in code : " + printTokens(getLangProcessError(processLang(T)))) if not processLang(T) :: StmtAST .


    eq processComponents('routes`{_`}[TL]) = routes(processRoutes(TL)) .

    ceq processComponents('persistent_=_;['token[T], T1]) = persistent(
        string(downTerm(T, '$err)), 
        toIO(
            getValue(evalExpr(processLang(T1), [ empty | empty | stack(0, empty) ])),
            getState(evalExpr(processLang(T1), [ empty | empty | stack(0, empty) ]))
        )
    ) if evalExpr(processLang(T1), [ empty | empty | stack(0, empty) ]) :: EvalResult .
    
    ceq processComponents('persistent_=_;['token[T], T1]) = compositionError(
        "Error in persistent " + string(downTerm(T, '$err)) + ": " + getError(
            evalExpr(processLang(T1), [ empty | empty | stack(0, empty) ])
    ))
    if not evalExpr(processLang(T1), [ empty | empty | stack(0, empty) ]) :: EvalResult .

    op processRoutes : TermList ~> SemRouter .
    eq processRoutes('__[T, T1]) = processRoutes(T), processRoutes(T1) .
    ceq processRoutes('_->_[T, 'token[T1]]) = route(
        downTerm(T, ""), 
        string(downTerm(T1, '$err))
    ) if valid(string(downTerm(T1, '$err))).

    op processConfig : TermList ~> Configuration .
    eq processConfig('__[T, T1]) = processConfig(T) processConfig(T1) .
    eq processConfig(empty) = none .
    eq processConfig('service_`{_`}['token[T], T1]) = service(
        string(downTerm(T, '$err)),
        server(
            processComponents(T1)
        )
    ) .
    eq processConfig('init`{_`}[T]) = init(processLang(T)) .
    eq processConfig('props`{_`}[T]) = none .

    op processProps : TermList ~> StmtAST .
    eq processProps('__[T, T1]) = processProps(T) ; processProps(T1) .
    eq processProps(T) = pass [owise] .
    eq processProps('props`{_`}[T]) = processLang(T) .


    op getCompositionError : [Configuration] -> QidList .
    
    var ~CONF : [Configuration] .
    var CONF : Configuration .
    var S : SemServiceId .
    var STR : String .
    var SERV : SemComponentList .
    var ~SERV : [SemComponentList] .
    var COMPONENT : SemComponent .
    var ERR : [String] .
    var ~CODE : [AST] .
    var CODE : AST .

    eq getCompositionError(~CONF) = 'Unknown '\s 'Composition '\s 'Error [owise] .
    --- eq getCompositionError(init(CODE) ~CONF) = getCompositionError(~CONF) .
    --- eq getCompositionError(init(~CODE) ~CONF) = getLangProcessError(~CODE) [owise] .
    --- eq getCompositionError(service(S, server(SERV)) ~CONF) = getCompositionError(~CONF) .
    --- eq getCompositionError(service(STR, server(~SERV)) ~CONF) = "Error in service " + STR + ": " + getComponentError(~SERV) [owise] .

    --- op getComponentError : [SemComponentList] -> String .
    --- eq getComponentError(~SERV) = "Unknown Component Error" [owise] .
    --- eq getComponentError(COMPONENT, ~SERV) = getComponentError(~SERV) [owise] .
    --- eq getComponentError(compositionError(ERR), ~SERV) = ERR .
endm


mod LANG-EXECUTION is
    protecting CONFIGURATION .
    protecting LANG-SEMANTICS .
    protecting STD-STREAM .
    protecting QID-LIST .

    sort Environment .

    op {_} : Configuration -> Environment [ctor] .

    op executor : -> Oid [ctor] .
    op Executor : -> Cid [ctor] .

    op currentResult :_ : [EvalResult] -> Attribute [ctor] .
    op initialState :_ : [State] -> Attribute [ctor] .
    op waiting :_ : IO? -> Attribute [ctor] .

    sort IO? .
    subsort IO < IO? .
    op none : -> IO? [ctor] .
    
    --- generate starting environment with predefined functions and initial declaration code
    op initiate : StmtAST FuncStorage -> Environment [ctor] .

    var CONF : Configuration .
    var ~RES : [EvalResult] .
    var RES : EvalResult .
    var STATE : State .
    var FUNCS : FuncStorage .
    var VARS : VarStorage .
    var STACK : Stack .
    var CODE : StmtAST .
    var ATTRS : AttributeSet .

    eq initiate(CODE, FUNCS) = {< executor : Executor | 
            currentResult : {void, getState(evalStmt(CODE, [ FUNCS | empty | stack(0, empty) ]))}, 
            initialState : getState(evalStmt(CODE, [ FUNCS | empty | stack(0, empty) ])),
            waiting : none
        >}
    .

    op evaluate : Environment StmtAST ~> Environment .
    op evaluate : StmtAST -> Msg [ctor] .
    op evaluating : StmtAST -> Msg [ctor] .
    eq evaluate({CONF}, CODE) = {CONF evaluate(CODE)} .

    rl 
        < executor : Executor | 
            currentResult : RES,
            ATTRS
        >
        evaluate(CODE)
    =>
        < executor : Executor |
            currentResult : evalStmt(CODE, getState(RES)), 
            ATTRS
        >
        evaluating(CODE)
    .

    op connectionOut : -> IO [ctor] .
    op outcomingRequest : String String IOValue -> Msg [ctor] .
    op incomingResponse : IOValue -> Msg [ctor] .

    op defaultFunctions : -> FuncStorage .
    eq defaultFunctions =
        func("request", params(id("svc"), id("path"), id("payload")), $dispatch(list(id("svc"), id("path"), id("payload")), connectionOut) ; $lock(id("res"), connectionOut) ; return(id("res")))
    .

    vars SERVICE PATH : String .
    var IOVAL : IOValue .

    rl < executor : Executor | 
            currentResult : dispatched(~RES, list(strVal(SERVICE) strVal(PATH) IOVAL), connectionOut), 
            waiting : none,
            ATTRS
        >
    =>
        < executor : Executor | 
            currentResult : ~RES,
            waiting : connectionOut,
            ATTRS
        >
        outcomingRequest(SERVICE, PATH, IOVAL)
    .

    rl < executor : Executor | 
            currentResult : ~RES, 
            waiting : connectionOut,
            ATTRS
        >
        incomingResponse(IOVAL)
    =>
        < executor : Executor | 
            currentResult : unlock(~RES, IOVAL),
            waiting : none,
            ATTRS
        >
    .
endm

mod SERVER-EXECUTION is
    protecting LANG-EXECUTION .

    --- messages to communicate with executing service
    op responseSent : IOValue -> Msg [ctor] .
    op setPersistent : String IOValue -> Msg [ctor] .
    op setPersistentOk : -> Msg [ctor] .
    op getPersistent : String -> Msg [ctor] .
    op persistentValue : IOValue -> Msg [ctor] .

    --- types of communication from language to executor
    op connectionIn : -> IO [ctor] .
    op setPersistentValue : -> IO [ctor] .
    op getPersistentValue : -> IO [ctor] .

    --- message to initiate execution of controller for IO request
    op callController : Environment String IOValue ~> Environment .
    op callController : String IOValue -> Msg [ctor] .
    eq callController({CONF}, CONTR, IOVAL) = {CONF callController(CONTR, IOVAL)} .

    var CONF : Configuration .
    var IOVAL : IOValue .
    vars CONTR ARG NAME : String .
    var ~RES : [EvalResult] .
    var RES : EvalResult .
    var STATE : State .
    var FUNCS : FuncStorage .
    var VARS : VarStorage .
    var STACK : Stack .
    var CODE : StmtAST .
    var ATTRS : AttributeSet .

    rl 
        < executor : Executor | 
            currentResult : ~RES, 
            initialState : ([ FUNCS ; func(CONTR, params(id(ARG)), CODE) | VARS | STACK ]),
            ATTRS
        >
        callController(CONTR, IOVAL)
    =>
        < executor : Executor | 
            currentResult : evalStmt(CODE, assignVar(ARG, getValue(toVal(IOVAL, [ FUNCS ; func(CONTR, params(id(ARG)), CODE) | VARS | STACK ])), getState(toVal(IOVAL, [ FUNCS ; func(CONTR, params(id(ARG)), CODE) | VARS | STACK ])))), 
            initialState : getState(toVal(IOVAL, [ FUNCS ; func(CONTR, params(id(ARG)), CODE) | VARS | STACK ])),
            ATTRS
        >
    .

    --- definition of predefined functions
    op serverFunctions : -> FuncStorage .
    eq serverFunctions =
        defaultFunctions ;
        func("respond", params(id("value")), $dispatch(id("value"), connectionIn)) ;
        func("setPersistent", params(id("key"), id("value")), $dispatch(list(id("key"), id("value")), setPersistentValue) ; $lock(id("res"), setPersistentValue)) ;
        func("getPersistent", params(id("key")), $dispatch(id("key"), getPersistentValue) ; $lock(id("res"), getPersistentValue) ; return(id("res"))) 
    .

    rl < executor : Executor | 
            currentResult : dispatched(~RES, IOVAL, connectionIn), 
            ATTRS
        >
    =>
        < executor : Executor | 
            currentResult : ~RES,
            ATTRS
        >
        responseSent(IOVAL)
    .

    rl < executor : Executor | 
            currentResult : dispatched(~RES, list(strVal(NAME) IOVAL), setPersistentValue), 
            waiting : none,
            ATTRS
        >
    =>
        < executor : Executor | 
            currentResult : ~RES,
            waiting : setPersistentValue,
            ATTRS
        >
        setPersistent(NAME, IOVAL)
    .

    rl < executor : Executor | 
            currentResult : ~RES,
            waiting : setPersistentValue,
            ATTRS
        >
        setPersistentOk
    =>
        < executor : Executor | 
            currentResult : unlock(~RES, boolVal(true)),
            waiting : none,
            ATTRS
        >
    .

    rl < executor : Executor | 
            currentResult : dispatched(~RES, strVal(NAME), getPersistentValue), 
            waiting : none,
            ATTRS
        >
    =>
        < executor : Executor | 
            currentResult : ~RES,
            waiting : getPersistentValue,
            ATTRS
        >
        getPersistent(NAME)
    .

    rl < executor : Executor | 
            currentResult : ~RES,
            waiting : getPersistentValue,
            ATTRS
        >
        persistentValue(IOVAL)
    =>
        < executor : Executor | 
            currentResult : unlock(~RES, IOVAL),
            waiting : none,
            ATTRS
        >
    .


    op initiateServer : StmtAST String IOValue ~> Environment .
    eq initiateServer(CODE, CONTR, IOVAL) = callController(initiate(CODE, serverFunctions), CONTR, IOVAL) .
    
endm


---(
    interaction between servers and initialization of server side execution
)
mod SERVER-SEMANTICS is
    protecting SERVER-AST .
    protecting SERVER-EXECUTION .
    protecting LANG-EXECUTION .
    protecting CONFIGURATION .

    op process : SemConnection Environment -> SemComponent [ctor] .
    op process : SemConnection Environment Nat -> SemComponent [ctor] .

    var ID ID' : Nat .
    var PATH PATH' CONTR ARG NAME : String .
    vars S S' S'' : SemServiceId .
    var SERV : SemComponentList .
    var CODE : StmtAST .
    var STATE : State .
    var ROUTER : SemRouter .
    var V V' RESP BODY REQ : IOValue .
    var FUNCS : FuncStorage .
    var VARS : VarStorage .
    var STACK : Stack .
    var CONF : Configuration .
    var CONN : SemConnection .

    rl [CONSUME-REQUEST] : 
        connection(ID, S, S', httpRequest(PATH, V))
        service(S', server(SERV, code(CODE), routes(route(PATH, CONTR), ROUTER)))
    =>
        service(S', server(SERV, 
            code(CODE),
            routes(route(PATH, CONTR), ROUTER), 
            process(connection(ID, S, S', httpRequest(PATH, V)), initiateServer(CODE, CONTR, V))
        ))
    .

    rl [SEND-RESPONSE] : 
        service(S', server(SERV, 
        process(
            connection(ID, S, S', httpRequest(PATH, V)), 
            { responseSent(RESP) CONF }
        )
    ))
    =>
        service(S', server(SERV))
        connection(ID, S, S', httpRequest(PATH, V), response(RESP))
    .

    rl [SEND-REQUEST] : 
        connectionManager(ID)
        service(S', server(SERV, 
            process(
                CONN, 
                { outcomingRequest(S'', PATH', REQ) CONF }
            )
        ))
    =>
        connectionManager(ID + 1)
        connection(ID, S', S'', httpRequest(PATH', REQ))
        service(S', server(SERV, 
            process(
                CONN,
                { CONF },
                ID
            )
        ))
    .

    rl [CONSUME-RESPONSE] : 
        connection(ID, S', S'', httpRequest(PATH', REQ), response(RESP))
        service(S', server(SERV, 
            process(
                CONN, 
                { CONF },
                ID
            )
        ))
    =>
        service(S', server(SERV, 
            process(
                CONN, 
                { incomingResponse(RESP) CONF }
            )
        ))
    .

    rl initManager(ID) init(CODE) 
    => 
        initManager(ID + 1) 
        service(initId(ID), server(process(dummyConnection, initiate(CODE, defaultFunctions)))) 
    .

    rl [GET-PERSISTENT] : 
        service(S, server(SERV,
            persistent(NAME, V), 
            process(
                CONN, 
                { getPersistent(NAME) CONF }
            )
        ))
    =>
        service(S, server(SERV,
            persistent(NAME, V), 
            process(
                CONN, 
                { persistentValue(V) CONF }
            )
        ))
    .

    rl [SET-PERSISTENT] :
        service(S, server(SERV,
            persistent(NAME, V), 
            process(
                CONN, 
                { setPersistent(NAME, V') CONF }
            )
        ))
    =>
        service(S, server(SERV,
            persistent(NAME, V'), 
            process(
                CONN, 
                { setPersistentOk CONF }
            )
        ))
    .
endm

mod PRINTER is
    protecting LEXICAL .
    protecting META-LEVEL .
    protecting SERVER-SEMANTICS .

    op printAst : Term ~> QidList .
    op printAst : Term Nat ~> QidList .

    vars T T' T'' T1 T2 T3 T4 T5 : Term .
    vars TL TL' : TermList .
    var N : Nat .

    op tabs : Nat -> QidList .
    eq tabs(s(N)) = '\t tabs(N) .
    eq tabs(0) = nil .

    
    eq printAst(T) = printAst(T, 0) .

    eq printAst(T, N) = tabs(N) metaPrettyPrint(['SERVER-SEMANTICS], none, T, mixfix format number rat) [owise] .

    eq printAst('__[T, TL], N) = if printAst(T, N) =/= nil then printAst(T, N) '\n else nil fi printAst('__[TL], N) .
    eq printAst('_`,_[T, TL], N) = if printAst(T, N) =/= nil then printAst(T, N) '\n else nil fi printAst('__[TL], N) .
    eq printAst('__[empty], N) = nil .

    eq printAst('service[T, T'], N) = tabs(N) 'service '\s printAst(T, 0) '\s '`{ '\n printAst(T', s(N)) '\n tabs(N) '`} .
    eq printAst('server[T], N) = printAst(T, N) .
    eq printAst('code[T], N) = tabs(N) 'code '\s '`{ '... ---(printAst(T, s(N)) + "\n" + tabs(N)) '`} .
    eq printAst('routes[T], N) = tabs(N) 'routes '\s '`{ '... ---(printAst(T, s(N)) + "\n" + tabs(N)) '`} .
    eq printAst('process[T, T', T''], N) = tabs(N) 'process '\s 'for '\s printInnerConnection(T, s(N)) '\s ': '\s '`[ '\s 'waiting 'connection '\s printAst(T'') '\s '`] .
    eq printAst('process[T, T'], N) = tabs(N) 'process '\s 'for '\s printInnerConnection(T, s(N)) '\s ': '\s '`[ '\s printProcessStatus(T', s(N)) '\s '`] .
    --- eq printAst('map[T], N) = tabs(N) + "{" + printMapEntries(T) + "}" .

    --- op printMapEntries : Term ~> String .
    --- eq printMapEntries('_`,_[T, T']) = printMapEntries(T) + ", " + printMapEntries(T') .
    --- eq printMapEntries('_|->_[T, T']) = printAst(T) + " : " + printAst(T') . 
    
    op printInnerConnection : Term Nat ~> QidList .
    eq printInnerConnection('connection[T, T1, T2, 'httpRequest[T3, T4]], N) = 'CONN '\s ': 's printAst(T) '\s '| '\s printAst(T3) '\s '~ '\s printAst(T4) .
    eq printInnerConnection('dummyConnection.SemConnection, N) = 'init .


    op printProcessStatus : Term Nat ~> QidList .
    eq printProcessStatus(T, N) = printProcessStatus(downTerm(T, { none }), N) [owise] .

    var CONF : Configuration .
    var O : Oid .
    var ATTRS : AttributeSet .
    var Io : IO .
    vars S S' PATH : String .
    var REQ RESP IOVAL : IOValue .
    var RES : EvalResult .
    var ~RES : [EvalResult] .

    op printProcessStatus : Environment Nat ~> QidList .
    eq printProcessStatus({ none }, N) = 'empty .
    eq printProcessStatus({ outcomingRequest(S, PATH, REQ) CONF }, N) = 'sent '\s 'request '\s 'to '\s '`[ tokenize(S) '\s '@ '\s tokenize(PATH) '`] '\s ': '\n tabs(N) printAst(upTerm(REQ)) '\s '. .
    eq printProcessStatus({ incomingResponse(RESP) CONF }, N) = 'got '\s 'response '\s ': '\s printAst(upTerm(RESP)) '\s '. .
    eq printProcessStatus({ setPersistent(S, IOVAL) CONF }, N) = 'setting '\s 'persistent '\s tokenize(S) '\s '= '\s printAst(upTerm(IOVAL)) '\s '. .
    eq printProcessStatus({ setPersistentOk CONF }, N) = 'persistent '\s 'changed '\s '. .
    eq printProcessStatus({ < O : Executor | ATTRS, waiting : getPersistentValue > CONF }, N) = 'waiting '\s 'for '\s 'access '\s 'to '\s 'persistent '\s 'value .
    eq printProcessStatus({ < O : Executor | ATTRS, currentResult : RES, waiting : none > CONF }, N) = 'ended '\s 'execution .
    eq printProcessStatus({ < O : Executor | ATTRS, currentResult : dispatched(~RES, IOVAL, Io), waiting : none > CONF }, N) = 'language '\s 'dispathed '\s printAst(upTerm(IOVAL)) '\s 'to '\s 'channel '\s printAst(upTerm(Io)) .
    eq printProcessStatus({ CONF }, N) = printAst(upTerm(CONF), N) [owise] .
endm

mod COMPOSITION-TO-LANGUAGE is
    protecting SERVER-SEMANTICS .
    protecting CONVERSION .

    op toState : Configuration ~> State .
    op toState : Configuration State ~> State .

    op assertion : -> IO .

    op serverToIOVal : SemComponentList -> IOValue .
    op connectionToIOVal : SemConnection -> IOValue .

    var O : Object .
    var St : State .
    var CONF : Configuration .
    vars S S' PATH STR : String .
    vars ID ID1 ID2 ID3 : Nat .
    var REQ : SemRequest .
    var SERV : SemComponentList .
    var ENV : Environment .
    var CODE : StmtAST .
    vars VAL RESP : IOValue .
    var CONN : SemConnection .


    eq toState(CONF) = toState(CONF, [ 
        func("assert", params(id("value")), $dispatch(id("value"), assertion)) 
        | "services" := 0 ; "connections" := 1
        | stack(2, 0 |-> dictVal(empty) ; 1 |-> listVal(emptyList))
    ]) .

    --- eq toState(O CONF, St) = toState(CONF, St) [owise] .
    eq toState(<> CONF, St) = toState(CONF, St) .
    eq toState(initManager(ID) CONF, St) = toState(CONF, St) .
    eq toState(init(CODE) CONF, St) = toState(CONF, St) .
    eq toState(none, St) = St .
    eq toState(connectionManager(ID) CONF, St) = toState(CONF, assignVar("totalConnections", intVal(ID), St)) .
    eq toState(service(initId(ID), server(SERV)) CONF, St) = toState(CONF, St) .
    eq toState(service(S, server(SERV)) CONF, St) = toState(
        CONF, 
        assignValue(
            getRef(getValue(evalRefExpr(
                member(id("services"), S), 
                getState(toVal(serverToIOVal(SERV), St))
            ))), 
            getValue(toVal(serverToIOVal(SERV), St)), 
            getState(evalRefExpr(
                member(id("services"), S), 
                getState(toVal(serverToIOVal(SERV), St))
            ))
        ) 
    ) .
    eq toState(CONN CONF, St) = toState(
        CONF, 
        assignValue(
            getRef(getValue(evalRefExpr(
                id("connections"),
                getState(toVal(connectionToIOVal(CONN), St))
            ))), 
            listVal(getList(getStackValue(getRef(getValue(evalRefExpr(
                id("connections"),
                getState(toVal(connectionToIOVal(CONN), St))
            ))), getState(evalRefExpr(
                id("connections"),
                getState(toVal(connectionToIOVal(CONN), St))
            )))), lastIndex(getStack(getState(toVal(connectionToIOVal(CONN), St))))), 
            pushStack(
                getValue(toVal(connectionToIOVal(CONN), St)),
                getState(toVal(connectionToIOVal(CONN), St))
            )
        ) 
    ) .

    var SERVCOMP : SemComponent .

    eq serverToIOVal(SERVCOMP, SERV) = serverToIOVal(SERV) [owise] .
    eq serverToIOVal($empty)  = map("persistents" |-> map(empty)) .
    eq serverToIOVal(persistent(STR, VAL), SERV) = map(
        insert(
            "persistents", 
            map(
                insert(
                    STR, 
                    VAL, 
                    getMap(getMap(serverToIOVal(SERV))["persistents"])
                )
            ), 
            getMap(serverToIOVal(SERV))
        )
    ) .

    eq connectionToIOVal(connection(ID, S, S', httpRequest(PATH, VAL))) = map((
        "id" |-> intVal(ID) ,
        "from" |-> strVal(S) ,
        "to" |-> strVal(S') ,
        "path" |-> strVal(PATH) ,
        "payload" |-> VAL ,
        "hasResponse" |-> boolVal(false)
    )) .
    eq connectionToIOVal(connection(ID, S, S', httpRequest(PATH, VAL), response(RESP))) = map((
        "id" |-> intVal(ID) ,
        "from" |-> strVal(S) ,
        "to" |-> strVal(S') ,
        "path" |-> strVal(PATH) ,
        "payload" |-> VAL ,
        "hasResponse" |-> boolVal(true),
        "response" |-> RESP
    )) .
    eq connectionToIOVal(connection(ID, initId(ID1), S', httpRequest(PATH, VAL))) = map((
        "id" |-> intVal(ID) ,
        "from" |-> strVal("init-" + string(ID1, 10)) ,
        "to" |-> strVal(S') ,
        "path" |-> strVal(PATH) ,
        "payload" |-> VAL ,
        "hasResponse" |-> boolVal(false)
    )) .
    eq connectionToIOVal(connection(ID, initId(ID1), S', httpRequest(PATH, VAL), response(RESP))) = map((
        "id" |-> intVal(ID) ,
        "from" |-> strVal("init-" + string(ID1, 10)) ,
        "to" |-> strVal(S') ,
        "path" |-> strVal(PATH) ,
        "payload" |-> VAL ,
        "hasResponse" |-> boolVal(true),
        "response" |-> RESP
    )) .
endm

mod ASSERTION-CHECK is
    protecting SERVER-SEMANTICS .
    protecting COMPOSITION-TO-LANGUAGE .
    protecting BOOL .

    op satisfies : Configuration StmtAST ~> Bool .
    op checkAssertions : EvalResult ~> Bool .
    op checkValid : EvalResult ~> Bool .
    op noErrors : Configuration ~> Bool .
    op checkServValid : EvalResult ~> Bool .

    var St : State .
    var ~RES : [EvalResult] .
    var B : Bool .
    var CONF : Configuration .
    var CODE : StmtAST .

    eq satisfies(CONF, CODE) = if checkValid(evalStmt(CODE, toState(CONF))) and noErrors(CONF) then checkAssertions(evalStmt(CODE, toState(CONF))) else false fi .

    eq checkAssertions({ void, St }) = true .
    eq checkAssertions(dispatched(~RES, boolVal(B), assertion)) = B and checkAssertions(~RES) .
    
    eq checkValid({ void, St }) = true .
    eq checkValid(dispatched(~RES, boolVal(B), assertion)) = checkValid(~RES) .
    eq checkValid(~RES) = false [owise] .

    var S : SemServiceId .
    var SERV : SemComponentList .
    var EXEC : Oid .
    var CONN : SemConnection .
    var ATTRS : AttributeSet .
    var IOVAL : IOValue .
    var Io : IO .
    var N : Nat .
    --- var ~RES : [EvalResult] .

    eq noErrors(CONF service(S, server(SERV, process(CONN, {
        < EXEC : Executor | ATTRS, currentResult : ~RES >
    }))))
    = checkServValid(~RES) and noErrors(CONF) .

    eq noErrors(CONF) = true [owise] .

    eq checkServValid({ void, St }) = true .
    eq checkServValid({ void, locked(St, N, Io) }) = true .
    eq checkServValid(dispatched(~RES, IOVAL, Io)) = true .
    eq checkServValid(~RES) = false [owise] .
endm

--- mod COMPOSITION-INTEGRITY-CHECK is
---     protecting ASSERTION-CHECK .

---     op isCompositionValid : 
--- endm

mod COMPOSITION-PREDS is
    including (SATISFACTION + LTL + MODEL-CHECKER) * (sort State to CompositionState) .
    protecting ASSERTION-CHECK .

    subsort Configuration < CompositionState .

    op unhandledRequest : -> Prop [ctor] .
    
    op assertions : StmtAST -> Prop [ctor] .
    op prepareAssertions : StmtAST ~> Prop [ctor] .


    var CONF : Configuration .
    vars S S' PATH : String .
    var ID : Nat .
    var REQ : SemRequest .
    var SERV : SemComponentList .
    var ENV : Environment .
    var CODE : StmtAST .

    eq prepareAssertions(CODE) = assertions(CODE) .

    eq CONF connection(ID, S, PATH, REQ) |= unhandledRequest = true .
    eq CONF service(S, server(SERV, process(connection(ID, S', PATH, REQ), ENV))) |= unhandledRequest = true .
    eq CONF |= unhandledRequest = false [owise] .

    eq CONF |= assertions(CODE) = checkAssertions(evalStmt(CODE, toState(CONF))) .
endm

mod COMPOSITION is
    protecting META-LEVEL .
    protecting QID-LIST .
    protecting LEXICAL .
    protecting INT .
    protecting CONFIGURATION .
    protecting FILE-READER .
    protecting STRING .
    protecting SERVER .
    protecting SERVER-SEMANTICS .
    protecting PRINTER .
    protecting COMPOSITION-PREDS .

    sort Term? .
    subsort Term < Term? .
    op noTerm : -> Term? .

    op Composition : -> Cid [ctor] .
    op composition : -> Oid [ctor] .

    op metaTerm :_ : Term? -> Attribute [ctor] .

    op writeMetaTerm : Oid Oid Term -> Msg [ctor msg] .
    op wroteMetaTerm : Oid Oid -> Msg [ctor msg] .

    op getMetaTerm : Oid Oid -> Msg [ctor msg] .
    op gotMetaTerm : Oid Oid Term? -> Msg [ctor msg] .
    

    op initComposition : ~> Configuration .
    eq initComposition = < composition : Composition | metaTerm : noTerm > .

    vars O O' O'' COMP PARSER : Oid .
    vars T T' : Term .
    var T? : Term? .
    vars ATTRS ATTRS' : AttributeSet .

    rl < COMP : Composition | metaTerm : T? > writeMetaTerm(COMP, O, T)
    => < COMP : Composition | metaTerm : T > wroteMetaTerm(O, COMP) .
    
    rl < COMP : Composition | metaTerm : T? > getMetaTerm(COMP, O)
    => < COMP : Composition | metaTerm : T? > gotMetaTerm(O, COMP, T?) .


    op stringParser : -> Oid [ctor] .
    op StringParser : -> Cid [ctor] .

    op sender :_ : Oid -> Attribute [ctor] .

    op parseTermFromString : Oid Oid String -> Msg [ctor msg] .
    op parsedTermFromString : Oid Oid -> Msg [ctor msg] .
    op failedParse : Oid Oid ConfigurationOrError -> Msg [ctor msg] .

    var TEXT : String .

    sort ConfigurationOrError .
    subsort Configuration < ConfigurationOrError .
    op parseError : String -> ConfigurationOrError .

    op parseComposition : String -> ResultPair? .
    eq parseComposition(TEXT) = metaParse(upModule('SERVER-SYNTAX, false), tokenize(TEXT), 'ServiceList) .
    
    op toConfig : String -> ConfigurationOrError .
    ceq toConfig(TEXT) = processConfig(getTerm(parseComposition(TEXT))) 
    if parseComposition(TEXT) :: ResultPair .

    ceq toConfig(TEXT) = generateError(TEXT, parseComposition(TEXT))
    if not parseComposition(TEXT) :: ResultPair .

    vars I I' : Int .
    vars N N' : Nat .
    var QID : Qid .
    var QLIST : QidList .

    op formatErrorString : String ResultPair? -> QidList .
    eq formatErrorString(TEXT, noParse(I)) = 'Failed '\s 'to '\s 'parse: '\s subQidList(tokenize(TEXT), _-_(I, 19), 20) '\s '<-- '\s 'HERE .

    op formatErrorString : QidList ResultPair? -> QidList .
    eq formatErrorString(QLIST, noParse(I)) = 'Failed '\s 'to '\s 'parse: '\s subQidList(QLIST, _-_(I, 19), 20) '\s '<-- '\s 'HERE .

    op generateError : String ResultPair? -> ConfigurationOrError .
    eq generateError(TEXT, noParse(I)) = parseError("Failed to parse: " + printTokens(subQidList(tokenize(TEXT), _-_(I, 19), 20)) + " <-- HERE") .

    op subQidList : QidList Int Nat -> QidList .
    ceq subQidList(QLIST, I, N') = subQidList(QLIST, 0, N' + I) if I < 0 .
    ceq subQidList(QID QLIST, I, N) = subQidList(QLIST, _-_(I, 1), N) if I > 0 .
    eq subQidList(QID QLIST, 0, s(N)) = QID subQidList(QLIST, 0, N) .
    eq subQidList(QLIST, I, 0) = nil .
    eq subQidList(nil, I, N) = nil .

    op initConfig : -> Configuration .
    eq initConfig = connectionManager(0) initManager(0) <> .

    crl < COMP : Composition | ATTRS > parseTermFromString(COMP, O, TEXT)
    => < COMP : Composition | ATTRS > 
        writeMetaTerm(COMP, stringParser, upTerm(initConfig toConfig(TEXT))) 
        < stringParser : StringParser | sender : O > 
    if toConfig(TEXT) :: Configuration .

    crl < COMP : Composition | ATTRS > parseTermFromString(COMP, O, TEXT)
    => < COMP : Composition | ATTRS > 
        failedParse(O, COMP, toConfig(TEXT))
    if not toConfig(TEXT) :: Configuration .

    rl wroteMetaTerm(PARSER, COMP) 
        < PARSER : StringParser | sender : O > 
    => parsedTermFromString(O, composition) .

    var F : String .

    op fileParser : -> Oid [ctor] .
    op FileParser : -> Cid [ctor] .

    op fileName :_ : String -> Attribute [ctor] .
    op receiver :_ : Oid -> Attribute [ctor] .

    op parseTermFromFile : Oid Oid String -> Msg [ctor msg] .
    op parsedTermFromFile : Oid Oid -> Msg [ctor msg] .

    rl < COMP : Composition | ATTRS > parseTermFromFile(COMP, O, F)
    => < COMP : Composition | ATTRS >
        < fileParser : FileParser | sender : O, fileName : F, receiver : COMP > 
        scanFile(F) .

    rl scannedFile(F, TEXT) 
        < PARSER : FileParser | sender : O, fileName : F, receiver : COMP > 
    => parseTermFromString(COMP, O, TEXT) .


    op simulate : Oid Oid -> Msg [ctor msg] .
    op simulated : Oid Oid Term -> Msg [ctor msg] .

    rl < COMP : Composition | metaTerm : T, ATTRS > simulate(COMP, O)
    => < COMP : Composition | metaTerm : T, ATTRS > simulated(O, COMP, getTerm(metaRewrite(upModule('COMPOSITION, true), T, unbounded))) .

    
    op simulateAndPrint : Oid Oid -> Msg [ctor msg] .
    op waitingForPrint : Oid Oid -> Msg [ctor msg] .
    op simulatedAndPrinted : Oid Oid -> Msg [ctor msg] .

    op debug : Universal -> Msg [ctor poly (1)] .

    rl simulateAndPrint(COMP, O)
    => simulate(COMP, O) waitingForPrint(O, COMP) .

    rl simulated(O, COMP, T) waitingForPrint(O, COMP)
    => write(stdout, COMP, printTokens(printAst(T))) waitingForPrint(O, COMP) .

    rl wrote(COMP, O') waitingForPrint(O, COMP)
    => simulatedAndPrinted(O, COMP) .

    --- op check : Oid Oid Formula -> Msg [ctor msg] .
    --- op checked : Oid Oid ModelCheckResult -> Msg [ctor msg] .

    --- op printCheckResult : ModelCheckResult -> String .
    --- op printCheckResultShort : ModelCheckResult -> String .
    --- op printCounterexample : TransitionList -> String .

    --- var LTL : Formula .
    --- var RES : ModelCheckResult .
    --- vars CE CE' : TransitionList .
    --- var RULE : RuleName .
    --- var CONF : Configuration .
    
    --- eq printCheckResult(true) = "Valid\n" .
    --- eq printCheckResult(counterexample(CE, CE')) = "Invalid: \nStarting at:\n" + printCounterexample(CE) + "\nWith loop:\n" + printCounterexample(CE') .
    --- eq printCheckResultShort(counterexample(CE, CE')) = "Invalid:\nWith loop:\n" + printCounterexample(CE') .

    --- ceq printCounterexample({CONF, RULE} CE) = printCounterexample(CE) if RULE == unlabeled .
    --- ceq printCounterexample({CONF, RULE} CE) = printAst(upTerm(CONF)) + "\n ---> \n" + printCounterexample(CE) if RULE =/= unlabeled .
    --- eq printCounterexample(nil) = "END\n" . 


    --- rl < COMP : Composition | metaTerm : T, ATTRS > check(COMP, O, LTL)
    --- => < COMP : Composition | metaTerm : T, ATTRS > checked(O, COMP, modelCheck(downTerm(T, none), LTL)) .

    --- op checkAndPrint : Oid Oid Formula -> Msg [ctor msg] .
    --- op checkedAndPrinted : Oid Oid -> Msg [ctor msg] .

    --- rl checkAndPrint(COMP, O, LTL)
    --- => check(COMP, O, LTL) waitingForPrint(O, COMP) .

    --- rl checked(O, COMP, RES) waitingForPrint(O, COMP)
    --- => write(stdout, COMP, printCheckResult(RES)) .


    --- op checker : -> Oid [ctor] .
    --- op Checker : -> Cid [ctor] .

    --- op code :_ : StmtAST -> Attribute [ctor] .

    --- op loadAssertionCode : Oid Oid String -> Msg [msg] .
    --- op loadedAssertionCode : Oid Oid -> Msg [msg] .

    --- vars CODE CODE' : StmtAST .

    --- rl < O : Checker | code : CODE, receiver : O'', ATTRS > loadAssertionCode(O, O', F) 
    --- => scanFile(F) < O : Checker | code : CODE, receiver : O', ATTRS > .

    --- rl < O : Checker | code : CODE, receiver : O', ATTRS > scannedFile(F, TEXT)
    --- => < O : Checker | code : CODE ; parse(TEXT), receiver : O', ATTRS > loadedAssertionCode(O', O) .

    --- op loadAssertions : String String ~> Prop [ctor] .
    --- eq loadAssertions(TEXT, F) = prepareAssertions(parseFile(F) ; parse(TEXT)) .
endm

select COMPOSITION .